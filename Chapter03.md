# Chapter03
# 第三章 内存管理 习题
- - - -
##  知识点小记
1. 当一个进程发生缺页中断的时候，进程会陷入**内核态**，执行以下操作：
1、检查要访问的虚拟地址是否合法
2、查找/分配一个物理页
3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）
4、建立映射关系（虚拟地址到物理地址）
2. 当发生缺页中断/缺页错误时，操作系统要找一个较少使用的页框，把它的内容写回磁盘。把刚才需要访问的页面读到刚回收的页框中，修改MMU中的映射关系，有两处：将回收的虚拟页面的表项标记为未映射，把新装入的虚拟页面的页框号修改成回收的页框，并标记为已映射。
3. 16位的虚拟地址分为4位的页号和12位的偏移量。四位页号可以表示16个页面。页号作为页表的索引，以得到对应于虚拟页面的页框号。
4. 加速分页过程：
1.转换检测缓冲区（快表）（TLB）：将一个虚拟地址放入MMU中进行转换时，硬件首先将该虚拟页号与TLB中所有表项同时（并行）进行匹配，如果发现了有效匹配就直接从TLB中取出页框号，而不必再访问页表。如果没有有效匹配项，MMU就会进行正常的页表查询，接着从TLB中淘汰一个表象，用新找到的页表项代替它。
2.软件TLB管理。
5. 针对大内存的页表：
1.多级页表：顶级页表-二级页表-·······
2.倒排页表（反置页表）：表项和物理内存中的页框数量一样
6. 页面置换算法：
* OPT最优页面置换算法（不可能实现）
* NRU最近未使用页面置换算法：访问位R，修改位M，初始值设置为0，R位被定期清零。
* FIFO先进先出页面置换算法：发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。
* Second Chance第二次机会页面置换算法：对FIFO的修改，如果表头的R位是0，则淘汰，若为1，则将R清零，并放回表尾。
* Clock时钟页面置换算法：把所有页面保存在环形链表中，用一个表针指向最老的页面，避免了在链表中移动页面。发生缺页中断时，首先检查指针指向的页面，如果R位是0，则淘汰，若为1，则将R位清零，并把指针前移一个位置。
* LRU最近最少未使用页面置换算法：在缺页中断发生时，置换未使用时间最长的页面，实现代价很高。
* NFU最不常用算法：每个页面与一个软件计数器相关联，每次发生时钟中断，将每个页面的R位加到计数器上。
* Aging老化算法：修改NFU，变成老化算法可以很好的模拟LRU。每次记录R位时，先将计数器右移，然后把R的值加到最高位。发生缺页中断时，将置换计数器值最小的页面。有两点区别：1.无法区分一个时钟滴答中页面访问的先后顺序。2.老化算法的计数器位数是有限的，限制了对以往页面的记录。
* 工作集页面置换算法：发生缺页中断时，淘汰一个不在工作集中的页面。工作集是最近k次内存访问所使用过的页面的集合。但是计算出工作集并不容易，常见的方法是用一定时间内内存访问的页面的集合作为工作集的近似。需要记录上次访问时间。
* WSClock工作集时钟页面置换算法 ：与时钟算法有点类似，把所有页面保存在环形链表中。发生缺页中断时，首先检查指针指向的页面，若为1，则将R位清零，并把指针前移一个位置。如果R位是0，则计算生存时间，并与t比较，若大于t且页面是干净的（在磁盘上有副本），则淘汰页面，否则指针前移。
* PFF缺页中断率算法：计算每秒的缺页中断数，调整分配集（给进程在内存中分配多少页框）的大小。
7. 分页守护进程：定期被唤醒以检查内存的状况，空闲页框过少，则根据算法选择页面换出内存，如果页面被修改过，就写回磁盘。如果想使用一个被淘汰的页面，且页框还没有被覆盖，则可以从空闲页框缓冲池中移出并恢复该页面。
8. **缺页中断处理**：
* 硬件陷入内核，堆栈保存程序计数器PC，把当前指令的状态保存在特殊的CPU寄存器中。
* 启动汇编代码例程保存通用寄存器和易失信息。
* 操作系统尝试发现需要那个虚拟页面，如果硬件寄存器没有包含这一信息，操作系统必须检索程序计数器，取出指令，并用软件分许。
* 知道了发生缺页中断的虚拟地址后，先检查这个地址是否有效，并检查存取与保护是否一致：若不一致，向进程发出信号或杀死进程；若地址有效且没有保护错误，则检查是否有空闲页框，若没有则用页面置换算法寻找一个页面来淘汰。
* ·······
* 当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。
* 恢复缺页中断发生前的状态，程序指令器重新指向引起缺页中断的指令。
* 调度引起页面中断的进程，操作系统返回汇编代码例程。
* 汇编代码例程恢复现场，将之前保存在通用寄存器中的信息恢复。
9. 













